<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<title>Pipeline Editor</title>
	<link rel="stylesheet" href="/css/editor.css">
</head>

<body>
	<h2>Pipeline Editor</h2>
	<div id="controls"></div>
	<div id="imagesRow" class="row"
		style="min-height:300px; background:#f8f8f8; border:1px solid #ccc; margin-bottom:2em; align-items:center;">
	</div>
	<div id="errorMsg" style="color:red; margin-top:1em;"></div>
	<script>
		// Helper debounce function
		function debounce(fn, delay) {
			let timer = null;
			return function (...args) {
				if (timer) clearTimeout(timer);
				timer = setTimeout(() => fn.apply(this, args), delay);
			};
		}

		const imagesRow = document.getElementById('imagesRow');
		const errorMsg = document.getElementById('errorMsg');
		const controls = document.getElementById('controls');

		// Render images
		function renderImages(urls) {
			imagesRow.innerHTML = '';
			urls.forEach(url => {
				const img = document.createElement('img');
				img.src = url + '?t=' + Date.now();
				img.className = 'img-preview';
				imagesRow.appendChild(img);
			});
		}

		// Run pipeline and render images
		function runPipeline() {
			errorMsg.textContent = '';
			fetch('/api/session/pipeline/run', { method: 'POST' })
				.then(async res => {
					if (res.ok) {
						const urls = await res.json();
						renderImages(urls);
					} else {
						let err;
						try { err = await res.json(); } catch { err = { error: 'Unknown', message: res.statusText }; }
						errorMsg.textContent = (err.error ? err.error + ': ' : '') + (err.message || JSON.stringify(err));
					}
				})
				.catch(e => {
					errorMsg.textContent = 'Network error: ' + e;
				});
		}

		// Fetch operation info and create sliders
		function fetchOperationInfo() {
			fetch('/api/session/pipeline/operations/info')
				.then(async res => {
					if (res.ok) {
						const infos = await res.json();
						controls.innerHTML = '';
						infos.forEach((info, idx) => {
							const opDiv = document.createElement('div');
							opDiv.style.display = 'inline-block';
							opDiv.style.margin = '0 2em 2em 0';
							opDiv.style.padding = '1em';
							opDiv.style.border = '1px solid #ddd';
							opDiv.style.background = '#fafafa';
							opDiv.style.verticalAlign = 'top';
							opDiv.style.minWidth = '220px';
							const title = document.createElement('div');
							title.textContent = info.name;
							title.style.fontWeight = 'bold';
							title.style.marginBottom = '0.5em';
							opDiv.appendChild(title);
							info.paramSpecs.forEach(spec => {
								console.log('Param spec:', spec);
								if (spec.type === 'Integer(2^n)') {
									// For Integer(2^n), slider is in log2 space
									const label = document.createElement('label');
									label.textContent = spec.name + ': ';
									label.htmlFor = `slider-${idx}-${spec.name}`;
									label.style.marginRight = '0.5em';
									const slider = document.createElement('input');
									slider.type = 'range';
									slider.id = `slider-${idx}-${spec.name}`;
									// Compute log2 min/max/default
									const log2 = x => Math.log2(x);
									const pow2 = n => Math.pow(2, n);
									const minExp = Math.round(log2(spec.minValue));
									const maxExp = Math.round(log2(spec.maxValue));
									const defaultExp = Math.round(log2(spec.defaultValue));
									slider.min = minExp;
									slider.max = maxExp;
									slider.value = defaultExp;
									slider.step = 1;
									slider.style.width = '120px';
									const valueSpan = document.createElement('span');
									valueSpan.textContent = pow2(slider.value);
									valueSpan.style.marginLeft = '0.5em';
									slider.oninput = function () {
										valueSpan.textContent = pow2(slider.value);
										debouncedUpdateParam(idx, spec.name, pow2(slider.value));
									};
									opDiv.appendChild(label);
									opDiv.appendChild(slider);
									opDiv.appendChild(valueSpan);
									opDiv.appendChild(document.createElement('br'));
								} else if (spec.type === 'Integer') {
									const label = document.createElement('label');
									label.textContent = spec.name + ': ';
									label.htmlFor = `slider-${idx}-${spec.name}`;
									label.style.marginRight = '0.5em';
									const slider = document.createElement('input');
									slider.type = 'range';
									slider.id = `slider-${idx}-${spec.name}`;
									slider.min = spec.minValue;
									slider.max = spec.maxValue;
									slider.value = spec.defaultValue;
									slider.step = 1;
									slider.style.width = '120px';
									const valueSpan = document.createElement('span');
									valueSpan.textContent = slider.value;
									valueSpan.style.marginLeft = '0.5em';
									slider.oninput = function () {
										valueSpan.textContent = slider.value;
										debouncedUpdateParam(idx, spec.name, parseInt(slider.value));
									};
									opDiv.appendChild(label);
									opDiv.appendChild(slider);
									opDiv.appendChild(valueSpan);
									opDiv.appendChild(document.createElement('br'));
								}
								if (spec.type === 'Double' || spec.type === 'Float') {
									const label = document.createElement('label');
									label.textContent = spec.name + ': ';
									label.htmlFor = `slider-${idx}-${spec.name}`;
									label.style.marginRight = '0.5em';
									const slider = document.createElement('input');
									slider.type = 'range';
									slider.id = `slider-${idx}-${spec.name}`;
									slider.min = spec.minValue;
									slider.max = spec.maxValue;
									console.log('Default value for', spec.name, 'is', spec.defaultValue);
									console.log('Min value for', spec.name, 'is', spec.minValue);
									console.log('Max value for', spec.name, 'is', spec.maxValue);
									console.log(slider.value);
									//console.log(typeof spec.defaultValue);
									console.log(String(spec.defaultValue));
									slider.value = String(spec.defaultValue);
									console.log('Slider value for', spec.name, 'set to', slider.value);
									console.log('Slider min for', spec.name, 'is', slider.min);
									console.log('Slider max for', spec.name, 'is', slider.max);
									console.log(typeof slider.value);
									slider.step = (spec.maxValue - spec.minValue) / 100 || 0.01;
									slider.style.width = '120px';
									const valueSpan = document.createElement('span');
									valueSpan.textContent = slider.value;
									
									valueSpan.style.marginLeft = '0.5em';
									slider.oninput = function () {
										valueSpan.textContent = slider.value;
										debouncedUpdateParam(idx, spec.name, parseFloat(slider.value));
									};
									opDiv.appendChild(label);
									opDiv.appendChild(slider);
									opDiv.appendChild(valueSpan);
									opDiv.appendChild(document.createElement('br'));
								}
							});
							controls.appendChild(opDiv);
						});
					}
				});
		}

		// Debounced update param logic
		const updateParamTimers = {};
		function debouncedUpdateParam(idx, paramName, value) {
			if (updateParamTimers[idx]) clearTimeout(updateParamTimers[idx]);
			updateParamTimers[idx] = setTimeout(() => {
				const payload = {
					index: idx,
					values: { [paramName]: value }
				};
				fetch('/api/session/pipeline/operations/update-param', {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify(payload)
				})
					.then(async res => {
						if (res.ok) {
							const urls = await res.json();
							renderImages(urls);
						} else {
							let err;
							try { err = await res.json(); } catch { err = { error: 'Unknown', message: res.statusText }; }
							errorMsg.textContent = (err.error ? err.error + ': ' : '') + (err.message || JSON.stringify(err));
						}
					})
					.catch(e => {
						errorMsg.textContent = 'Network error: ' + e;
					});
			}, 1000);
		}

		// On page load, run pipeline and fetch operation info
		window.addEventListener('DOMContentLoaded', () => {
			runPipeline();
			fetchOperationInfo();
		});
	</script>
</body>

</html>